<template>
  <WaccaProfileRequired>
    <v-container>
      <v-alert type="info" class="mb-2">
        <p>
          This page shows you your total rating for your top 100 songs.
        </p>
        <p>
          Each song shows you the achieved rating, as well as a guide on how
          much rating you will gain by improving your PB to the next rating
          border.
        </p>
        <p>
          The left number shows the improvement for the song, the right number
          shows how much rating your whole profile will gain.
        </p>
      </v-alert>

      <v-tabs fixed-tabs v-model="tab" bg-color="primary">
        <v-tab v-if="sheetFolders.length" :key="sheetFolders.length - 1">
          {{ sheetFolders[sheetFolders.length - 1].name }}
          <v-chip>{{ sheetFolders[sheetFolders.length - 1].count }}</v-chip>

          {{ sheetFolders[sheetFolders.length - 1].rating.toFixed(3) }}
        </v-tab>
      </v-tabs>


      <v-window v-model="tab">
        <div v-if="sheetFolders.length" :key="sheetFolders.length - 1">
          <div class="rating-holder">
            <div
              v-for="(sheet, j) in sheetFolders[sheetFolders.length - 1].sheets"
              :key="sheet"
            >
              <NuxtLink
                style="text-decoration: none"
                :to="`/wacca/songs/${sheet.song.id}`"
                class="rating-song"
              >
                <div class="rating-jacket">
                  <WaccaJacket :url="sheet.song.imageName" />
                </div>

                <div class="rating-info">
                  <div class="rating-title">
                    {{ getTitle(sheet.song) }}
                  </div>
                  <div
                    v-if="sheet.nextScore"
                    class="rating-suggestion"
                    :class="`difficulty-${sheet.difficulty}`"
                  >
                  
                    <div>
                      {{
                        waccaDifficulties[sheet.difficulty].name
                          .toUpperCase()
                          .slice(0, 3)
                      }}
                      +{{ sheet.nextScoreDiff }}
                    </div>
                    <div>
                      R +{{ sheet.ratingDiff.toFixed(3) }} / +{{
                        Math.max(0, sheet.ratingGain).toFixed(3)
                      }}
                    </div>
                  </div>
                  
                   <div
                    class="rating-best-score"
                    :style="{
                      background: getScoreGradient(sheet.score),
                    }"
                  >
                    {{ sheet.score.toLocaleString() }}
                  </div>

                  <div class="rating-difficulty" v-if="sheet.rating">
                    <WaccaDifficultyPillSmall
                      :i="sheet.difficulty + 1"
                      :difficulty="sheet.song.sheets[sheet.difficulty].difficulty"
                    />
                  </div>
                  <div class="rating-rating" v-if="sheet.rating">
                    <WaccaRating
                      :rating="sheet.rating"
                      :divide="50"
                      :simple="true"
                      :decimals="3"
                    />
                  </div>
                </div>
              </NuxtLink>

              <div
                v-if="j == sheetFolders[sheetFolders.length - 1].count - 1"
                class="cutoff"
              >
                <v-icon>mdi-content-cut</v-icon>
                Cutoff
                <v-icon>mdi-content-cut mdi-rotate-180</v-icon>
              </div>
            </div>
          </div>
        </div>
      </v-window>
    </v-container>
  </WaccaProfileRequired>
</template>

<style scoped lang="scss">
.rating-holder {
  display: flex;
  flex-direction: column;
  gap: 5px;
  margin: 10px 0;
}

.rating-song {
  color: var(--v-text-primary);
  display: flex;
  border-radius: 5px;
  border: 1px solid #333;
  background: rgb(var(--v-theme-surface));
  overflow: hidden;
}
.rating-best-score {
  font-size: 0.9rem;
  font-weight: 600;
  color: #fff;
  padding: 3px 8px;
  border-radius: 999px; // pill shape
  min-width: 90px;
  text-align: center;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
}


.rating-info {
  flex-grow: 1;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  padding: 10px;
  gap: 10px;
}

.rating-jacket {
  height: 60px;
  aspect-ratio: 1;
  flex-shrink: 1;
}

.rating-title {
  flex-grow: 1;
  overflow: hidden;        // prevent content from overflowing
  text-overflow: ellipsis; // add "..." when text is too long
  white-space: nowrap;     // keep it on a single line
}


.rating-rating {
  font-weight: 700;
  font-size: 1.5em;
}

.cutoff {
  display: flex;
  align-items: center;
  color: rgba(var(--v-theme-on-background), 0.5);
  gap: 10px;
  margin: 20px 0;
  font-size: 1.5em;
  font-weight: 400;

  &:before,
  &:after {
    content: "";
    flex-grow: 1;
    background: rgba(var(--v-theme-on-background), 0.5);
    height: 1px;
    font-size: 0px;
    line-height: 0px;
  }
}

.rating-suggestion {
  font-size: 0.8em;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;

  &.difficulty-0 {
    color: #009de6;
  }

  &.difficulty-1 {
    color: #fed131;
  }

  &.difficulty-2 {
    color: #fc06a3;
  }

  &.difficulty-3 {
    color: #4a004f;
  }
}
</style>

<script setup>
import waccaSongs from "~/assets/wacca/waccaSongs.js";
import waccaDifficulties from "~/assets/wacca/waccaDifficulties";
import waccaRateMulBorders from "~/assets/wacca/waccaRateMulBorders";

const language = useState("language");
const profile = useState("profile");

definePageMeta({
  middleware: ["auth"],
});

function getRating(difficulty, score) {
  for (let i = 0; i < waccaRateMulBorders.length; i++) {
    const border = waccaRateMulBorders[i];

    if (score >= border.min) {
      return border.multiplier * difficulty * 10;
    }
  }

  return 0;
}

const tab = ref(0);

const version = useState("version");

const sheetFolders = computed(() => {
  const folders = [
    {
      name: "Hidden",
      sheets: [],
      count: 0,
    },
    {
      name: "Wacca Nana+",
      sheets: [],
      count: 100,
    },
  ];

  // calculate rating potentials
  for (const music of profile.value.music) {
    let sheet = {};
    sheet.difficulty = music.music_difficulty - 1;
    sheet.score = music.score;
    sheet.song = waccaSongs.find((song) => song.id == music.music_id);

    if (
      sheet.song &&
      sheet.song.sheets[sheet.difficulty] &&
      sheet.song.sheets[sheet.difficulty].gameVersion <= version.value
    ) {
      sheet.rating = getRating(
        sheet.song.sheets[sheet.difficulty].difficulty,
        sheet.score
      );

      if (sheet.song.sheets[sheet.difficulty].gameVersion < 300) {
        folders[0].sheets.push(sheet);
      } else {
        folders[1].sheets.push(sheet);
      }
    }
  }

  // sort by rating
  for (const folder of folders) {
    folder.sheets.sort((a, b) => {
      return b.rating - a.rating;
    });

    for (const sheet of folder.sheets) {
      // find next rating border
      let nextBorder;

      for (let i = waccaRateMulBorders.length - 1; i >= 0; i--) {
        const border = waccaRateMulBorders[i];

        if (border.min > sheet.score) {
          nextBorder = border;
          break;
        }
      }

      if (nextBorder) {
        const sheetDifficulty = sheet.song.sheets[sheet.difficulty].difficulty;

        let lowestRating = 0;
        if (folder.sheets.length >= folder.count) {
          lowestRating = folder.sheets[folder.count - 1].rating / 10;
        }

        const ratingDiff =
          nextBorder.multiplier * sheetDifficulty - sheet.rating / 10;

        let ratingGain = nextBorder.multiplier * sheetDifficulty - lowestRating;

        if (sheet.rating / 10 >= lowestRating) {
          ratingGain = ratingDiff;
        }

        sheet.nextScore = nextBorder.min;
        sheet.nextScoreDiff = nextBorder.min - sheet.score;
        sheet.nextRating = nextBorder.multiplier * sheetDifficulty;
        sheet.ratingDiff = ratingDiff;
        sheet.ratingGain = ratingGain;
      }
    }
  }

  // calculate rating for each folder
  for (const folder of folders) {
    let rating = 0;

    for (let i = 0; i < folder.count; i++) {
      if (!folder.sheets[i]) {
        break;
      }

      rating += folder.sheets[i].rating;
    }

    folder.rating = rating / 10;
  }

  return folders;
});

function getTitle(song) {
  if (language.value === "ja") {
    return song.title;
  }

  return song.titleEnglish || song.title;
}
function getScoreGradient(score) {
  const ratio = score / 1000000;

  // Perfect score → rainbow gradient
  if (score === 1000000) {
    return `linear-gradient(135deg,
      red, orange, yellow, green, cyan, blue, violet, red)`;
  }

  // 0.999 → 0.990 (999000–990000), split into 10 equal bands of 100 points each
  if (ratio >= 0.990 && ratio < 0.999) {
    const stepIndex = Math.floor((score - 990000) / 100); // 0 → 89
    const hue = 300 - stepIndex; // 300° (magenta) → 210° (blueish) as you drop
    return `linear-gradient(135deg, hsl(${hue}, 80%, 60%), hsl(${hue}, 70%, 50%))`;
  }

  // 0.989 → 0.901 = pink/fuchsia
  if (ratio >= 0.901 && ratio < 0.990) {
    return `linear-gradient(135deg, #ff66cc, #ff3399)`;
  }

  // 0.900 → 0.800 = yellow
  if (ratio >= 0.800 && ratio < 0.901) {
    return `linear-gradient(135deg, #ffe066, #ffcc00)`;
  }

  // 0.799 or less = blue
  return `linear-gradient(135deg, #66a3ff, #3366ff)`;
}


</script>
